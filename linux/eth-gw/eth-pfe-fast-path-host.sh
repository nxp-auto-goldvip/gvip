#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright 2021 NXP
#
# This script implements the host machine logic for the L2/L3 forwarding
# fast path scenario using the PFE interfaces of the board.
#
# The fast path scenario demonstrates that the traffic can flow solely through
# the PFE peripheral, without any Linux netstack interaction. 
#
# This scenario presumes having a network route between PFE0 and PFE2 interfaces,
# which belong to a separate network namespace. The host is implied to have 2
# network adapters available in order to handle the TCP/UDP segments injected via
# iperf3 by the target machine. 
#
# The test metrics are available under a report generated by the "sar" Linux utility
# This script will take care of setting up the L3 route between the
# two interfaces and will provide the MAC address of the host interfaces
# that are connected to the PFE ports.

# shellcheck source=linux/eth-gw/eth-common-host.sh
source "${BASH_SOURCE[0]%/*}/eth-common-host.sh"

# Global constants
readonly target_script="eth-pfe-fast-path-target.sh"
readonly vlan_id=1

# Default values
host_mac_pfe0="00:00:00:00:00:00"
host_mac_pfe2="00:00:00:00:00:00"

_set_route() {
    local namespace=$1
    local interface=$2
    local ip=$3

    if [ "${ip}" = "10.0.1.1" ]; then
        ip netns exec "${namespace}" ip route add "192.168.100.0/24" via "10.0.1.2" dev "${interface}"
    else
        ip netns exec "${namespace}" ip route add "10.0.1.0/24" via "192.168.100.2" dev "${interface}"
    fi
}

# Set routing between the two network namespaces
setup_l3_router() {
    ping_return="${GENERAL_ERR}"

    echo "Checking connection to the device"
    _set_ip_for_netns "nw_ns0" "${eth_interface0}" "${ip_eth0}"
    ip netns exec nw_ns0 ping -c 4 "10.0.1.2" && ping_return=$?
    if [ ${ping_return} -ne 0 ]; then
        echo "Ports are swapped, reconfiguring target"
        ip_eth0="192.168.100.1"
        ip_eth1="10.0.1.1"

        # Cleanup target initial configuration
        _clean_target

        # Wait for execution to finish
        sleep 1

        # Swap ip addresses for the interfaces
        echo "/home/root/eth-gw/${target_script} -L ${layer_number}" -m0 "${host_mac_pfe2}" -m1 "${host_mac_pfe0}" -V ${vlan_id}> "${uart_dev}"
    else
        ip_eth0="10.0.1.1"
        ip_eth1="192.168.100.1"
    fi

    echo "Set IP ${ip_eth0} to ${eth_interface0} in nw_ns0 "
    _set_ip_for_netns "nw_ns0" "${eth_interface0}" "${ip_eth0}"
    echo "Set IP ${ip_eth1} to ${eth_interface1} in nw_ns1 "
    _set_ip_for_netns "nw_ns1" "${eth_interface1}" "${ip_eth1}"

    _set_route "nw_ns0" "${eth_interface0}" "${ip_eth0}"
    _set_route "nw_ns1" "${eth_interface1}" "${ip_eth1}"
}

# Check host interfaces configuration and setup target interfaces
_setup_target() {
    # Get interface MAC addresses
    host_mac_pfe0=$( cat /sys/class/net/"${eth_interface0}"/address )
    host_mac_pfe2=$( cat /sys/class/net/"${eth_interface1}"/address )

    if [ -z "${host_mac_pfe0}" ]; then
        echo "MAC address missing on interface ${eth_interface0}, connected to PFE0"
        exit "${INVALID_CONFIG_ERR}"
    fi
    if [ -z "${host_mac_pfe2}" ]; then
        echo "MAC address missing on interface ${eth_interface1}, connected to PFE2"
        exit "${INVALID_CONFIG_ERR}"
    fi

    echo "/home/root/eth-gw/${target_script} -L ${layer_number}" -m0 "${host_mac_pfe0}" -m1 "${host_mac_pfe2}" -V ${vlan_id} > "${uart_dev}"
}

# Delete bridge in case L2 routing is used
_disable_hw_bridge_target() {
    if [ "${layer_number}" -eq 2 ]; then
        echo "libfci_cli --bd_del_if --vlan" ${vlan_id} "--i emac0"> "${uart_dev}"
        echo "libfci_cli --bd_del_if --vlan" ${vlan_id} "--i emac2"> "${uart_dev}"
        echo "libfci_cli --bd_set_act --vlan" ${vlan_id} "--ucast_hit 3 --ucast_miss 3 --mcast_hit 3 --mcast_miss 3" > "${uart_dev}"
    fi
}

set_trap
check_input "$@"
_setup_target
setup_host
run_test
_disable_hw_bridge_target
show_log
clean_up
